# -*- coding: utf8 -*-
#
# Copyright 2012, Intel Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
"""
Created on 1 f√©vr. 2012

@author: Florent Vennetier
"""

import os

from mic import kickstart
from mic.kickstart.custom_commands.moblinrepo import Moblin_RepoData

import ObsLightErr
from ObsLightUtils import isNonEmptyString

# TODO: create a KickstartManagerException class

class ObsLightKickstartManager(object):
    # pylint: disable-msg=E0202, E1101

    # Commands that must not appear in getCommandList()
    SpecialCaseCommands = ("repo",) # handled separately

    # The tag used to identify OBS Light overlay file script
    OverlayFileScriptTag = "#- OBS Light overlay file script -#"

    def __init__(self, kickstartPath=None):
        self._kickstartPath = kickstartPath
        self._ksParser = None
        self._scriptCounter = 0
        # bidirectional mapping between script instances and script names
        self._scriptNameMap = {}
        if self.kickstartPath is not None:
            self.parseKickstart()

    @property
    def kickstartPath(self):
        return self._kickstartPath

    @kickstartPath.setter
    def kickstartPath(self, value): # pylint: disable-msg=E0102
        self._kickstartPath = value

    @property
    def kickstartParser(self):
        """
        The `pykickstart.parser.KickstartParser` instance used
        internally by `ObsLightKickstartManager`. May change after
        calling `parseKickstart`.
        """
        return self._ksParser

    def _checkKsFile(self):
        """
        Raise an exception if Kickstart file is not set
        or does not exist.
        """
        ks = self.kickstartPath
        if not isNonEmptyString(ks):
            msg = "No Kickstart file set"
            raise ObsLightErr.ObsLightMicProjectErr(msg)
        if not os.path.exists(ks):
            msg = "Kickstart file '%s' does not exist" % ks
            raise ObsLightErr.ObsLightMicProjectErr(msg)

    def _checkKsParser(self):
        """
        Calls `_checkKsFile` first and then
        raises an exception if Kickstart file has not been parsed
        or correctly parsed.
        """
        self._checkKsFile()
        if self.kickstartParser is None:
            msg = "Kickstart file not or incorrectly parsed"
            raise ObsLightErr.ObsLightMicProjectErr(msg)

    def parseKickstart(self):
        """
        Do the parsing of the Kickstart file.
        Raises `ObsLightErr.ObsLightMicProjectErr` if no Kickstart file is set.
        """
        self._checkKsFile()
        self._ksParser = kickstart.read_kickstart(self.kickstartPath)

    def saveKickstart(self, alternateFile=None):
        """
        Save the Kickstart to `alternateFile`,
        or to `self.kickstartPath` if `alternateFile` is None.
        """
        self._checkKsParser()
        fullKsString = "# Generated by OBS Light\n" + str(self.kickstartParser.handler)
        outputPath = self.kickstartPath
        if alternateFile is not None and isinstance(alternateFile, file):
            alternateFile.write(fullKsString)
        else:
            outputPath = self.kickstartPath if alternateFile is None else alternateFile
            with open(outputPath, "w") as outputFile:
                outputFile.write(fullKsString)

# --- Repositories -----------------------------------------------------------
    def getRepositoryList(self):
        """
        Get the list of packages repositories configured in the Kickstart
        file (only their name).
        """
        self._checkKsParser()
        retVal = [repo[0] for repo in kickstart.get_repos(self.kickstartParser)]
        retVal.sort()
        return retVal

    def _checkRepository(self, name):
        if not name in self.getRepositoryList():
            msg = "Repository '%s' does not exist" % name
            raise ObsLightErr.ObsLightMicProjectErr(msg)

    def __getRepoObj(self, name):
        for repo in self.kickstartParser.handler.repo.repoList:
            if repo.name == name:
                return repo

    def addRepositoryByConfigLine(self, line):
        """
        Add a repository to the Kickstart by specifying the whole
        configuration line.
        ex: "repo --name=adobe --baseurl=http://linuxdownload.adobe.com/linux/i386/ --save"
        """
        self._checkKsParser()
        kickstart.add_repo(self.kickstartParser, line)

    def addRepository(self, baseurl, name, cost=None, **kwargs):
        """
        Add a package repository in the Kickstart file.
         baseurl: the URL of the repository
         name:    a name for this repository
         cost:    the cost of this repository, from 0 (highest priority) to 99, or None
        Keyword arguments can be (default value from `Moblin_RepoData`):
        - mirrorlist (""):
        - priority (None):
        - includepkgs ([]):
        - excludepkgs ([]):
        - save (False): keep the repository in the generated image
        - proxy (None):
        - proxy_username (None):
        - proxy_password (None):
        - debuginfo (False):
        - source (False):
        - gpgkey (None): the address of the GPG key of this repository
            on the generated filesystem (ex: file:///etc/pki/rpm-gpg/RPM-GPG-KEY-meego)
        - disable (False): add the repository as disabled
        - ssl_verify ("yes"):
        """
        self._checkKsParser()
        if name in self.getRepositoryList():
            msg = "A repository with name '%s' already exists" % name
            raise ObsLightErr.ObsLightMicProjectErr(msg)
        repoObj = Moblin_RepoData(baseurl=baseurl, name=name, **kwargs)
        # cost is not available in the constructor of Moblin_RepoData
        # but exists in its parent class
        repoObj.cost = cost
        self.kickstartParser.handler.repo.repoList.append(repoObj)

    def removeRepository(self, name):
        """
        Remove the package repository `name` from the Kickstart file.
        """
        self._checkRepository(name)
        for i in range(len(self.kickstartParser.handler.repo.repoList)):
            repo = self.kickstartParser.handler.repo.repoList[i]
            if repo.name == name:
                del self.kickstartParser.handler.repo.repoList[i]
                break

    def getRepositoryDict(self, name):
        """
        Get a dictionary object representing a repository,
        suitable for input to `addRepository`.
        """
        self._checkRepository(name)
        repoObj = self.__getRepoObj(name)
        myDict = dict(repoObj.__dict__)
        # these entries are no to be known by user and
        # may cause problems if dictionary is used as input
        # to addRepository
        myDict.pop("lineno", None)
        myDict.pop("preceededInclude", None)
        return myDict
# --- end Repositories -------------------------------------------------------

# --- Packages ---------------------------------------------------------------
    def getPackageList(self):
        """
        Get the list of packages configured in the Kickstart
        file.
        """
        self._checkKsParser()
        return kickstart.get_packages(self.kickstartParser)

    def getExcludedPackageList(self):
        """
        Get the list of excluded packages configured in the Kickstart
        file.
        """
        self._checkKsParser()
        return kickstart.get_excluded(self.kickstartParser)

    def getPackageGroupList(self):
        """
        Get the list of package groups configured in the Kickstart
        file.
        """
        self._checkKsParser()
        return [group.name for group in kickstart.get_groups(self.kickstartParser)]

    def __addRemovePackages(self, packageOrList, action="add", excluded=False, group=False):
        # if packageOrList is a string, transform it in a list of one string
        if isinstance(packageOrList, basestring):
            pkgList = [packageOrList]
        else:
            pkgList = packageOrList

        if action == "add":
            # The kickstartParser.handler.packages.add method takes a 
            # list of strings formatted as in the %packages section of
            # the Kickstart file:
            #  - package groups start with '@'
            #  - excluded packages or groups start with '-'
            if group:
                pkgList = [("@" + pkg) for pkg in pkgList]
            if excluded:
                pkgList = [("-" + pkg) for pkg in pkgList]
            self.kickstartParser.handler.packages.add(pkgList)
        elif action == "remove":
            # No method in kickstartParser.handler.packages to remove
            # packages from the different lists, so doing it by hand
            packagesObj = self.kickstartParser.handler.packages
            if group:
                # excludedGroupList may not exist
                groupList = packagesObj.excludedGroupList if excluded else packagesObj.groupList
                for groupName in pkgList:
                    for i in range(len(groupList)):
                        # groups are objects, not simple strings
                        if groupList[i].name == groupName:
                            del groupList[i]
                            break
            else:
                myList = packagesObj.excludedList if excluded else packagesObj.packageList
                for pkg in pkgList:
                    if pkg in myList:
                        myList.remove(pkg)

    def addPackage(self, packageOrList):
        """
        Add a package (or a list of) to the package list of the
        Kickstart file.
        """
        self._checkKsParser()
        self.__addRemovePackages(packageOrList, action="add", excluded=False)

    def addExcludedPackage(self, packageOrList):
        """
        Add a package (or a list of) to be explicitly excluded
        in the package list of the Kickstart file.
        """
        self._checkKsParser()
        self.__addRemovePackages(packageOrList, action="add", excluded=True)

    def removePackage(self, packageOrList):
        """
        Remove a package (or a list of) from the package list of the
        Kickstart file. Does nothing if package was not in the list.
        """
        self._checkKsParser()
        self.__addRemovePackages(packageOrList, action="remove", excluded=False)

    def removeExcludedPackage(self, packageOrList):
        """
        Remove a package (or a list of) from the explicitly excluded
        package list of the Kickstart file.
        Does nothing if package was not in the list.
        """
        self._checkKsParser()
        self.__addRemovePackages(packageOrList, action="remove", excluded=True)

    def addPackageGroup(self, packageOrList):
        """
        Add a package group (or a list of) to the package section of
        the Kickstart file.
        """
        self._checkKsParser()
        self.__addRemovePackages(packageOrList, action="add", excluded=False, group=True)

    def removePackageGroup(self, packageOrList):
        """
        Remove a package group (or a list of) from the package section
        of the Kickstart file.
        Does nothing if package group was not in the list.
        """
        self._checkKsParser()
        self.__addRemovePackages(packageOrList, action="remove", excluded=False, group=True)

    # Excluded package groups seems to be unsupported
#    def getExcludedPackageGroupList(self):
#        """
#        Get the list of excluded package groups configured in the
#        Kickstart file.
#        """
#        self._checkKsParser()
#        if not hasattr(self.kickstartParser.handler.packages, "excludedGroupList"):
#            return []
#        return [group.name for group in self.kickstartParser.handler.packages.excludedGroupList]
#
#    def addExcludedPackageGroup(self, packageOrList):
#        """
#        Add a package group (or a list of) to be explicitly excluded
#        in the package section of the Kickstart file.
#        """
#        self._checkKsParser()
#        self.__addRemovePackages(packageOrList, action="add", excluded=True, group=True)
#
#    def removeExcludedPackageGroup(self, packageOrList):
#        """
#        Remove a package group (or a list of) from the explicitly excluded
#        package list of the Kickstart file.
#        Does nothing if package group was not in the list.
#        """
#        self._checkKsParser()
#        self.__addRemovePackages(packageOrList, action="remove", excluded=True, group=True)
# --- end Packages -----------------------------------------------------------

# --- Commands ---------------------------------------------------------------
    def getCommandList(self):
        """
        Get the list of available Kickstart commands,
        minus `ObsLightKickstartManager.SpecialCaseCommands` (handled separately).
        """
        self._checkKsParser()
        actualCommands = self.kickstartParser.handler.commands.keys()
        for bannedCommand in ObsLightKickstartManager.SpecialCaseCommands:
            try:
                actualCommands.remove(bannedCommand)
            except ValueError:
                pass
        return actualCommands

    def getFilteredCommandDictList(self):
        """
        Get a list of kickstart command dictionaries containing:
          "name": the command name
          "in_use": True if the command is used in the current Kickstart file, False otherwise
          "generated_text": the text that is printed in the Kickstart file by this command
          "aliases": a list of command aliases
        """
        self._checkKsParser()
        # Find which command is an alias of another
        cmdObjDict = {}
        for cmd in self.getCommandList():
            cmdObj = self.kickstartParser.handler.commands[cmd]
            if not cmdObj in cmdObjDict:
                cmdObjDict[cmdObj] = [cmd]
            else:
                cmdObjDict[cmdObj].append(cmd)
        # Build the final command list
        filteredCommands = []
        for cmdObj in cmdObjDict:
            generatedText = str(cmdObj)
            cmdDict = {"name": cmdObjDict[cmdObj][0], # we take the first alias
                       "in_use": (len(generatedText.strip()) > 0),
                       "generated_text": generatedText,
                       "aliases": cmdObjDict[cmdObj]}
            filteredCommands.append(cmdDict)
        return filteredCommands

    def addOrChangeCommand(self, fullText, command=None):
        """
        Add a new Kickstart command, or modify an existing one.
        To add a new command, just pass the whole commandline in `fullText`.
        To change an existing command, it is preferable to pass the command
        name (or an alias) in `command` so that the old commandline can be
        erased first.
        """
        self._checkKsParser()
        if command is not None:
            cmdObj = self.kickstartParser.handler.commands[command]
            if cmdObj.dataList() is not None:
                # we must do something to erase old data objects
                del cmdObj.dataList()[:]
            else:
                # nothing to do since the reading of the new command options
                # will erase the old command options
                pass
        # call main parser with str(fulltext) in case of fullText is unicode
        self.kickstartParser.readKickstartFromString(str(fullText), reset=False)

    def removeCommand(self, command):
        """
        Remove `command` from the Kickstart file.
        `command` must be a command name or an alias,
        but not the whole text generated by a command.
        """
        self._checkKsParser()
        cmdObj = self.kickstartParser.handler.commands[command]
        # If command has multiple data, clear them.
        if cmdObj.dataList() is not None:
            del cmdObj.dataList()[:]
        # Else reset the command object
        elif len(str(cmdObj).strip()) > 1:
            cmdObj.__init__()
# --- end Commands -----------------------------------------------------------

# --- Scripts ----------------------------------------------------------------
    def getScriptDictList(self):
        """
        Get a list of script dictionaries containing (default value):
          "name": the name of the script (generated by OBS Light)
          "type": the type of script, one of
               pykickstart.constants.[KS_SCRIPT_PRE, KS_SCRIPT_POST, KS_SCRIPT_TRACEBACK]
          "interp": the interpreter to use to run the script ('/bin/sh')
          "errorOnFail": whether to quit or continue the script if a command fails (False)
          "inChroot": whether to run inside the chroot or outside (False)
          "logfile": the path where to log the output of the script (None)
          "script": all the lines of the script
        """
        self._checkKsParser()
        scriptDictList = []
        for scriptObj in self.kickstartParser.handler.scripts:
            # do not add overlay file scripts
            if scriptObj.script.lstrip().startswith(self.OverlayFileScriptTag):
                continue
            # make a copy of the object's attribute dictionary
            scriptDict = dict(scriptObj.__dict__)
            # remove the line number since we don't care
            scriptDict.pop("lineno", None)
            # find or generate a name for the script
            if scriptObj in self._scriptNameMap:
                scriptName = self._scriptNameMap[scriptObj]
            else:
                scriptName = "script %d" % self._scriptCounter
                self._scriptCounter += 1
            scriptDict["name"] = scriptName
            # save the name of the script
            self._scriptNameMap[scriptName] = scriptObj
            self._scriptNameMap[scriptObj] = scriptName

            scriptDictList.append(scriptDict)
        return scriptDictList

    def addOrChangeScript(self, name=None, script="", **kwargs):
        """
        Add a new Kickstart script, or modify an existing one.
        To add a new script, leave `name` at None.
        To change an existing script, you must pass the script name
        in `name`. `script` and other keyword args are those described
        in `getScriptDictList()`.
        """
        if name is not None and name in self._scriptNameMap:
            scriptObj = self._scriptNameMap[name]
            scriptObj.__dict__.update({"script": str(script)})
            scriptObj.__dict__.update(kwargs)
        else:
            scriptObj = kickstart.ksparser.Script(script=script, **kwargs)
            self.kickstartParser.handler.scripts.append(scriptObj)

    def removeScript(self, scriptName):
        """
        Remove script `scriptName` from the Kickstart file.
        """
        # get the script object and remove it from the name map
        scriptObj = self._scriptNameMap.pop(scriptName, None)
        # if it was not in the map, just return
        if scriptObj is None:
            return
        # remove the script object from Kickstart
        self.kickstartParser.handler.scripts.remove(scriptObj)
        # remove the name of the script from the name map
        self._scriptNameMap.pop(scriptObj)
# --- end Scripts ------------------------------------------------------------
