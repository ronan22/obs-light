#!/usr/bin/env python
# Authors Dominig ar Foll (Intel OTC) (first versions in Bash)
#         Florent Vennetier (Intel OTC) (third version in Python)
# Date 13 February 2012
# Version 3.2
# License GPLv2
#
# Credit Thanks to Yan Yin for providing the initial version used as a base
#

import sys
import os
import urllib
import urllib2
import urlparse

from osc import conf, core

def help_(progName="obs2obscopy"):
    print """HELP
Function : Copy a project from an OBS to an OBS, using as input a package list
           with the desired MD5 to represent the package revision.
           If target package is already at the correct revision, its copy
           is ignored. Running the script several time is possible until zero
           errors is acheived.
           A log file named <MD5_FILE>.log is created for everyrun.

Usage:     %s obs-alias source_prj target_prj md5_file
       or  %s obs-alias source_prj other-obs-alias target_prj md5_file
           md5_file is created by the script obstag

Example1: Local copy
       %s http://myObs.mynetwork:81 MyMeeGo:1.2:oss myTest:MeeGo:1.2:oss my_revision_tag.md5
Example2: Remote copy (by link)
       %s http://myObs.mynetwork:81 meego.com:MeeGo:1.2:oss myobs:MeeGo:1.2:oss my_revision_tag.md5
           where meego.com is a local projet which is a link to a remote OBS public api
Example3: Remote copy
       %s http://api.pub.meego.com Project:MINT:Testing http://myObs.mynetwork:81 myTest:MINT:Testing my_revision_tag.md5

Return code:
          0 success
          1 some packages not copied
          2 wrong number of arguments
          3 problem reading MD5 file or writing log file
          4 network error
          5 interrupted by user

Version 3.2  License GPLv2""" % (progName, progName, progName, progName, progName)

logFilePath = "/tmp/obs2obscopy.log"
logFile = None

def openlogfile():
    global logFilePath
    global logFile
    try:
        logFile = open(logFilePath, "wu")
    except IOError as e:
        print >> sys.stderr, "Cannot open", logFilePath, ":", e.strerror
        sys.exit(3)

def printerror(message):
    global logFile
    if logFile is None or logFile.closed:
        openlogfile()
    print >> sys.stderr, message
    print >> logFile, message

def printmessage(message, newline=True):
    global logFile
    if logFile is None or logFile.closed:
        openlogfile()
    if newline:
        print message
        print >> logFile, message
    else:
        print message,
        print >> logFile, message,

def makeurl(baseurl, l, query=[]):
    """
    Replacement for `osc.core.makeurl` which preserves the "path"
    part of the url.
    """

#    if conf.config['verbose'] > 1:
#        print 'makeurl:', baseurl, l, query,

    if type(query) == type(list()):
        query = '&'.join(query)
    elif type(query) == type(dict()):
        query = urllib.urlencode(query)

    scheme, netloc, path = urlparse.urlsplit(baseurl)[0:3]
    if len(path) > 0:
        l.insert(0, path)
    finalurl = urlparse.urlunsplit((scheme, netloc, '/'.join(l), query, ''))
    if conf.config['verbose'] > 1:
        print "->", finalurl
    return finalurl

def copy_pac(src_apiurl, src_project, src_package,
             dst_apiurl, dst_project, dst_package,
             client_side_copy=False,
             keep_maintainers=False,
             keep_develproject=False,
             expand=False,
             revision=None,
             comment=None):
    """
    Patched copy of osc 0.132.5 copy_pac() function.


    Create a copy of a package.

    Copying can be done by downloading the files from one package and commit
    them into the other by uploading them (client-side copy) --
    or by the server, in a single api call.
    """

    if not (src_apiurl == dst_apiurl and src_project == dst_project \
        and src_package == dst_package):
        src_meta = core.show_package_meta(src_apiurl, src_project, src_package)
        dst_userid = conf.get_apiurl_usr(dst_apiurl)
        src_meta = core.replace_pkg_meta(src_meta, dst_package, dst_project, keep_maintainers,
                                    dst_userid, keep_develproject)

        print 'Sending meta data...'
        u = makeurl(dst_apiurl, ['source', dst_project, dst_package, '_meta'])
        core.http_PUT(u, data=src_meta)

    print 'Copying files...'
    if not client_side_copy:
        query = {'cmd': 'copy', 'oproject': src_project, 'opackage': src_package }
        if expand:
            query['expand'] = '1'
        if revision:
            query['orev'] = revision
        if comment:
            query['comment'] = comment
        u = makeurl(dst_apiurl, ['source', dst_project, dst_package], query=query)
        f = core.http_POST(u)
        return f.read()

    else:
        # copy one file after the other
        import tempfile
        query = {'rev': 'upload'}
        revision = core.show_upstream_srcmd5(src_apiurl, src_project, src_package, expand=expand, revision=revision)
        for n in core.meta_get_filelist(src_apiurl, src_project, src_package, expand=expand, revision=revision):
            if n.startswith('_service:') or n.startswith('_service_'):
                continue
            print '  ', n
            tmpfile = None
            try:
                (fd, tmpfile) = tempfile.mkstemp(prefix='osc-copypac')
                os.close(fd)
                core.get_source_file(src_apiurl, src_project, src_package, n, targetfilename=tmpfile, revision=revision)
                u = makeurl(dst_apiurl, ['source', dst_project, dst_package, core.pathname2url(n)], query=query)
                core.http_PUT(u, file=tmpfile)
            finally:
                if not tmpfile is None:
                    os.unlink(tmpfile)
        if comment:
            query['comment'] = comment
        query['cmd'] = 'commit'
        u = makeurl(dst_apiurl, ['source', dst_project, dst_package], query=query)
        core.http_POST(u)
        return 'Done.'

def copyproject(apiUrl, srcProjectName, dstApiUrl, dstProjectName, tagFilePath):
    totalPkg = 0
    existPkg = 0
    copiedPkg = 0
    goodPkg = 0
    failPkg = 0
    goodLink = 0
    failLink = 0

    conf.get_config()
    core.makeurl = makeurl

    global logFilePath
    logFilePath = tagFilePath + ".log"
    openlogfile()

    try:
        tagFile = open(tagFilePath, "ru")
    except IOError as e:
        message = "Cannot open %s: %s" % (tagFilePath, e.strerror)
        printerror(message)
        sys.exit(3)
    message = "Copying revision version of source packages as defined in "
    message += tagFilePath
    printmessage(message)

    print "info : Checking connectivity with target project...",
    sys.stdout.flush()
    try:
        core.meta_get_packagelist(dstApiUrl, dstProjectName)
    except KeyboardInterrupt:
        raise
    except (urllib2.HTTPError, urllib2.URLError) as e:
        print
        if type(e) == urllib2.HTTPError:
            strerror = str(e) + " (%s)" % e.url
        else:
            strerror = str(e.reason)
        message = "FAILED\nError: Target project '%s' cannot be reached: %s"\
            % (dstProjectName, strerror)
        printerror(message)
        sys.exit(4)
    print "OK"

    print "info : Checking connectivity with source project...",
    sys.stdout.flush()
    try:
        core.meta_get_packagelist(apiUrl, srcProjectName)
    except KeyboardInterrupt:
        raise
    except (urllib2.HTTPError, urllib2.URLError) as e:
        print

        if type(e) == urllib2.HTTPError:
            strerror = str(e) + " (%s)" % e.url
        else:
            strerror = str(e.reason)
        message = "FAILED\nError: Source project '%s' cannot be reached: %s"\
            % (srcProjectName, strerror)
        printerror(message)
        sys.exit(4)
    print "OK"

    for line in tagFile:
        parts = line.split("|", 4) # only first 4 fields are relevant

        md5 = parts[0].strip()
        if len(parts) < 4 or parts[0].startswith("#"):
            continue
        elif len(md5) < 1:
            md5 = "latest"

        totalPkg += 1
        pkgName = parts[3].strip()

        packagePresent = False
        try:
            fileList = core.meta_get_filelist(dstApiUrl, dstProjectName,
                                              pkgName, revision=md5)
            if len(fileList) > 0:
                packagePresent = True
        except KeyboardInterrupt:
            raise
        except urllib2.HTTPError as e:
            if e.code == 404 or e.code == 400:
                packagePresent = False
            else:
                message = "Error: Cannot list files of package '%s': %s"\
                    % (pkgName, str(e))
                printerror(message)
                failPkg += 1
                continue
        except Exception as e:
            message = "Error: Cannot list files of package '%s': %s: %s\n"\
                % (pkgName, str(type(e)), str(e))
            printerror(message)
            failPkg += 1
            continue

        if not packagePresent:
            copiedPkg += 1
            message = "info : Copying %s from %s" % (pkgName, srcProjectName)
            printmessage(message, False)

            packageIsLink = False
            try:
                fileList = core.meta_get_filelist(apiUrl, srcProjectName, pkgName)
                if "_link" in fileList:
                    printmessage("(following the link) ", False)
                    packageIsLink = True
            except Exception as e:
                message = "\nError checking if %s is a link: '%s', trying standard copy"\
                    % (pkgName, str(e))
                printerror(message)

            try:
                print
                copy_pac(apiUrl, srcProjectName, pkgName,
                              dstApiUrl, dstProjectName, pkgName,
                              client_side_copy=(apiUrl != dstApiUrl),
                              revision=(None if packageIsLink else md5),
                              expand=packageIsLink)
                # I don't know if it can fail without returning an exception.
                # And we can't analyse the return value because it is sometimes
                # "Done." and sometimes an XML string (depending on the
                # value of parameter client_side_copy).
                if packageIsLink:
                    goodLink += 1
                else:
                    goodPkg += 1
                printmessage("DONE")

            except Exception as e:
                if packageIsLink:
                    failLink += 1
                else:
                    failPkg += 1
                message = "FAILED: %s" % (str(e))
                if type(e) == urllib2.HTTPError:
                    if e.code == 400 and md5 != "latest":
                        message += "\nMaybe revision '%s' is not available" % md5
                        message += "\n try 'curl -u user:password \"%s\"'" % e.url
                printmessage(message)

        else:
            existPkg += 1
            message = "info : %s is already present on %s" % (pkgName, dstProjectName)
            printmessage(message)

    tagFile.close()

    printmessage("Final reports")
    printmessage("   Total packages requested     = %s" % totalPkg)
    printmessage("   Packages existing on target  = %s" % existPkg)
    printmessage("   Packages needed copying      = %s" % copiedPkg)
    printmessage("   Packages copied              = %s" % goodPkg)
    printmessage("   Packages in error            = %s" % failPkg)
    printmessage("   Linked packages copied       = %s" % goodLink)
    printmessage("   Linked packages in error     = %s" % failLink)

    print "Log file available in %s" % logFilePath
    if failPkg != 0:
        sys.exit(1)


if __name__ == '__main__':
    try:
        if len(sys.argv) == 5:
            # Use same OBS URL as source and destination
            copyproject(sys.argv[1], sys.argv[2], sys.argv[1],
                 sys.argv[3], sys.argv[4])
        elif len(sys.argv) == 6:
            copyproject(sys.argv[1], sys.argv[2], sys.argv[3],
                 sys.argv[4], sys.argv[5])
        else:
            help_(sys.argv[0])
            sys.exit(2)
    except KeyboardInterrupt:
        print >> sys.stderr, "Interrupted by user..."
        sys.exit(5)
