# -*- coding: utf8 -*-
#
# Copyright 2012, Intel Inc.
#
# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; version 2 of the License.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU Library General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301, USA.
#
"""
Created on 1 f√©vr. 2012

@author: Florent Vennetier
"""

import os
import shutil

IS_AVAILABLE = False
try:
    from mic import kickstart
    from mic.kickstart import kserrors
    from mic.kickstart.custom_commands.moblinrepo import Moblin_RepoData
    IS_AVAILABLE = True
except ImportError:
    pass

import ObsLightErr
from ObsLightUtils import isNonEmptyString
from ObsLightTools import fileIsArchive

class ObsLightKickstartManager(object):
    """
    Manage configuration of a Kickstart file.
    """
    # pylint: disable-msg=E0202, E1101

    # Commands that must not appear in getCommandList()
    SpecialCaseCommands = ("repo",) # handled separately

    ArchiveFileExtensions = (".tar", ".tar.gz", ".tar.bz2", ".tgz", ".tbz", ".tz2", ".tar.xz")
    UntarCommand = 'tar -xf "%(source)s" -C "%(destination)s"'

    OverlayFilesDirectoryName = "overlays"
    # The tag used to identify OBS Light overlay file script
    OverlayFileScriptTag = "#- OBS Light overlay file script -#"
    OverlayFileSourceTag = "#- Source:"
    OverlayFileDestinationTag = "#- Destination:"

    def __init__(self, kickstartPath=None):
        self._kickstartPath = kickstartPath
        self._ksParser = None
        self._scriptCounter = 0
        # bidirectional mapping between script instances and script names
        self._scriptNameMap = {}
        if self.kickstartPath is not None:
            self.parseKickstart()

    @property
    def kickstartPath(self):
        """
        Get the path of the Kickstart file this object is managing.
        """
        return self._kickstartPath

    @kickstartPath.setter
    def kickstartPath(self, value): # pylint: disable-msg=E0102
        """
        Set the path of the Kickstart file this object is managing.
        You must call `parseKickstart()` for the change to be effective.
        """
        self._kickstartPath = value

    @property
    def kickstartParser(self):
        """
        The `pykickstart.parser.KickstartParser` instance used
        internally by `ObsLightKickstartManager`. May change after
        calling `parseKickstart`.
        """
        return self._ksParser

    @property
    def overlayFilesDirectory(self):
        """
        Get the path where overlay files of this project are stored.
        """
        return os.path.join(os.path.dirname(self.kickstartPath),
                            self.OverlayFilesDirectoryName)

    def _checkKsFile(self):
        """
        Raise an exception if Kickstart file is not set
        or does not exist.
        """
        ks = self.kickstartPath
        if not isNonEmptyString(ks):
            msg = "No Kickstart file set"
            raise ObsLightErr.ObsLightMicProjectErr(msg)
        if not os.path.exists(ks):
            msg = "Kickstart file '%s' does not exist" % ks
            raise ObsLightErr.ObsLightMicProjectErr(msg)

    def _checkKsParser(self):
        """
        Calls `_checkKsFile` first and then
        raises an exception if Kickstart file has not been parsed
        or correctly parsed.
        """
        self._checkKsFile()
        if self.kickstartParser is None:
            msg = "Kickstart file not or incorrectly parsed"
            raise ObsLightErr.ObsLightMicProjectErr(msg)

    def parseKickstart(self):
        """
        Do the parsing of the Kickstart file.
        Raises `ObsLightErr.ObsLightMicProjectErr` if no Kickstart file is set.
        """
        self._checkKsFile()
        try:
            self._ksParser = kickstart.read_kickstart(self.kickstartPath)
        except (IOError, ValueError, kserrors.KickstartError) as e:
            # ValueError may happen for example if a quotation mark is missing
            message = "Error while parsing '%s': %s: %s" % (self.kickstartPath,
                                                            str(type(e).__name__),
                                                            str(e))
            raise ObsLightErr.ObsLightKickstartError(message)

    def saveKickstart(self, alternateFile=None):
        """
        Save the Kickstart to `alternateFile`,
        or to `self.kickstartPath` if `alternateFile` is None.
        """
        self._checkKsParser()
        fullKsString = "# Generated by OBS Light\n" + str(self.kickstartParser.handler)
        outputPath = self.kickstartPath
        if alternateFile is not None and isinstance(alternateFile, file):
            alternateFile.write(fullKsString)
        else:
            outputPath = self.kickstartPath if alternateFile is None else alternateFile
            with open(outputPath, "w") as outputFile:
                outputFile.write(fullKsString)

# --- Repositories -----------------------------------------------------------
    def getRepositoryList(self):
        """
        Get the list of packages repositories configured in the Kickstart
        file (only their name).
        """
        self._checkKsParser()
        retVal = [repo[0] for repo in kickstart.get_repos(self.kickstartParser)]
        retVal.sort()
        return retVal

    def _checkRepository(self, name):
        if not name in self.getRepositoryList():
            msg = "Repository '%s' does not exist" % name
            raise ObsLightErr.ObsLightMicProjectErr(msg)

    def __getRepoObj(self, name):
        for repo in self.kickstartParser.handler.repo.repoList:
            if repo.name == name:
                return repo

    def addRepositoryByConfigLine(self, line):
        """
        Add a repository to the Kickstart by specifying the whole
        configuration line.
        ex: "repo --name=adobe --baseurl=http://linuxdownload.adobe.com/linux/i386/ --save"
        """
        self._checkKsParser()
        kickstart.add_repo(self.kickstartParser, line)

    def addRepository(self, baseurl, name, cost=None, **kwargs):
        """
        Add a package repository in the Kickstart file.
         baseurl: the URL of the repository
         name:    a name for this repository
         cost:    the cost of this repository, from 0 (highest priority) to 99, or None
        Keyword arguments can be (default value from `Moblin_RepoData`):
        - mirrorlist (""):
        - priority (None):
        - includepkgs ([]):
        - excludepkgs ([]):
        - save (False): keep the repository in the generated image
        - proxy (None):
        - proxy_username (None):
        - proxy_password (None):
        - debuginfo (False):
        - source (False):
        - gpgkey (None): the address of the GPG key of this repository
            on the generated filesystem (ex: file:///etc/pki/rpm-gpg/RPM-GPG-KEY-meego)
        - disable (False): add the repository as disabled
        - ssl_verify ("yes"):
        """
        self._checkKsParser()
        if name in self.getRepositoryList():
            msg = "A repository with name '%s' already exists" % name
            raise ObsLightErr.ObsLightMicProjectErr(msg)
        repoObj = Moblin_RepoData(baseurl=baseurl, name=name, **kwargs)
        # cost is not available in the constructor of Moblin_RepoData
        # but exists in its parent class
        repoObj.cost = cost
        self.kickstartParser.handler.repo.repoList.append(repoObj)

    def removeRepository(self, name):
        """
        Remove the package repository `name` from the Kickstart file.
        """
        self._checkRepository(name)
        for i in range(len(self.kickstartParser.handler.repo.repoList)):
            repo = self.kickstartParser.handler.repo.repoList[i]
            if repo.name == name:
                del self.kickstartParser.handler.repo.repoList[i]
                break

    def getRepositoryDict(self, name):
        """
        Get a dictionary object representing a repository,
        suitable for input to `addRepository`.
        Each dictionary contains:
         baseurl: the URL of the repository
         name:    a name for this repository
         cost:    the cost of this repository, from 0 (highest priority) to 99, or None
         mirrorlist (""):
         priority (None):
         includepkgs ([]):
         excludepkgs ([]):
         save (False): keep the repository in the generated image
         proxy (None):
         proxy_username (None):
         proxy_password (None):
         debuginfo (False):
         source (False):
         gpgkey (None): the address of the GPG key of this repository
                on the generated filesystem (ex: file:///etc/pki/rpm-gpg/RPM-GPG-KEY-meego)
         disable (False): add the repository as disabled
         ssl_verify ("yes"):
        """
        self._checkRepository(name)
        repoObj = self.__getRepoObj(name)
        myDict = dict(repoObj.__dict__)
        # these entries are no to be known by user and
        # may cause problems if dictionary is used as input
        # to addRepository
        myDict.pop("lineno", None)
        myDict.pop("preceededInclude", None)
        return myDict
# --- end Repositories -------------------------------------------------------

# --- Packages ---------------------------------------------------------------
    def getPackageList(self):
        """
        Get the list of packages configured in the Kickstart
        file.
        """
        self._checkKsParser()
        return kickstart.get_packages(self.kickstartParser)

    def getExcludedPackageList(self):
        """
        Get the list of excluded packages configured in the Kickstart
        file.
        """
        self._checkKsParser()
        return kickstart.get_excluded(self.kickstartParser)

    def getPackageGroupList(self):
        """
        Get the list of package groups configured in the Kickstart
        file.
        """
        self._checkKsParser()
        return [group.name for group in kickstart.get_groups(self.kickstartParser)]

    def __addRemovePackages(self, packageOrList, action="add", excluded=False, group=False):
        # if packageOrList is a string, transform it in a list of one string
        pkgList = [packageOrList] if isinstance(packageOrList, basestring) else packageOrList

        if action == "add":
            # The kickstartParser.handler.packages.add method takes a 
            # list of strings formatted as in the %packages section of
            # the Kickstart file:
            #  - package groups start with '@'
            #  - excluded packages start with '-'
            if group:
                pkgList = [("@" + pkg) for pkg in pkgList]
            if excluded:
                pkgList = [("-" + pkg) for pkg in pkgList]
            self.kickstartParser.handler.packages.add(pkgList)
        elif action == "remove":
            # No method in kickstartParser.handler.packages to remove
            # packages from the different lists, so doing it by hand
            packagesObj = self.kickstartParser.handler.packages
            if group:
                # excludedGroupList may not exist
                groupList = packagesObj.excludedGroupList if excluded else packagesObj.groupList
                for groupName in pkgList:
                    for i in range(len(groupList)):
                        # groups are objects, not simple strings
                        if groupList[i].name == groupName:
                            del groupList[i]
                            break
            else:
                myList = packagesObj.excludedList if excluded else packagesObj.packageList
                for pkg in pkgList:
                    if pkg in myList:
                        myList.remove(pkg)

    def addPackage(self, packageOrList):
        """
        Add a package (or a list of) to the package list of the
        Kickstart file.
        """
        self._checkKsParser()
        self.__addRemovePackages(packageOrList, action="add", excluded=False)

    def addExcludedPackage(self, packageOrList):
        """
        Add a package (or a list of) to be explicitly excluded
        in the package list of the Kickstart file.
        """
        self._checkKsParser()
        self.__addRemovePackages(packageOrList, action="add", excluded=True)

    def removePackage(self, packageOrList):
        """
        Remove a package (or a list of) from the package list of the
        Kickstart file. Does nothing if package was not in the list.
        """
        self._checkKsParser()
        self.__addRemovePackages(packageOrList, action="remove", excluded=False)

    def removeExcludedPackage(self, packageOrList):
        """
        Remove a package (or a list of) from the explicitly excluded
        package list of the Kickstart file.
        Does nothing if package was not in the list.
        """
        self._checkKsParser()
        self.__addRemovePackages(packageOrList, action="remove", excluded=True)

    def addPackageGroup(self, packageOrList):
        """
        Add a package group (or a list of) to the package section of
        the Kickstart file.
        """
        self._checkKsParser()
        self.__addRemovePackages(packageOrList, action="add", excluded=False, group=True)

    def removePackageGroup(self, packageOrList):
        """
        Remove a package group (or a list of) from the package section
        of the Kickstart file.
        Does nothing if package group was not in the list.
        """
        self._checkKsParser()
        self.__addRemovePackages(packageOrList, action="remove", excluded=False, group=True)

    # Excluded package groups seems to be unsupported
#    def getExcludedPackageGroupList(self):
#        """
#        Get the list of excluded package groups configured in the
#        Kickstart file.
#        """
#        self._checkKsParser()
#        if not hasattr(self.kickstartParser.handler.packages, "excludedGroupList"):
#            return []
#        return [group.name for group in self.kickstartParser.handler.packages.excludedGroupList]
#
#    def addExcludedPackageGroup(self, packageOrList):
#        """
#        Add a package group (or a list of) to be explicitly excluded
#        in the package section of the Kickstart file.
#        """
#        self._checkKsParser()
#        self.__addRemovePackages(packageOrList, action="add", excluded=True, group=True)
#
#    def removeExcludedPackageGroup(self, packageOrList):
#        """
#        Remove a package group (or a list of) from the explicitly excluded
#        package list of the Kickstart file.
#        Does nothing if package group was not in the list.
#        """
#        self._checkKsParser()
#        self.__addRemovePackages(packageOrList, action="remove", excluded=True, group=True)
# --- end Packages -----------------------------------------------------------

# --- Commands ---------------------------------------------------------------
    def getCommandList(self):
        """
        Get the list of available Kickstart commands,
        minus `ObsLightKickstartManager.SpecialCaseCommands` (handled separately).
        """
        self._checkKsParser()
        actualCommands = self.kickstartParser.handler.commands.keys()
        for bannedCommand in ObsLightKickstartManager.SpecialCaseCommands:
            try:
                actualCommands.remove(bannedCommand)
            except ValueError:
                pass
        return actualCommands

    def getFilteredCommandDictList(self):
        """
        Get a list of kickstart command dictionaries containing:
          "name": the command name
          "in_use": True if the command is used in the current Kickstart file, False otherwise
          "generated_text": the text that is printed in the Kickstart file by this command
          "aliases": a list of command aliases
        """
        self._checkKsParser()
        # Find which command is an alias of another
        cmdObjDict = {}
        for cmd in self.getCommandList():
            cmdObj = self.kickstartParser.handler.commands[cmd]
            if not cmdObj in cmdObjDict:
                cmdObjDict[cmdObj] = [cmd]
            else:
                cmdObjDict[cmdObj].append(cmd)
        # Build the final command list
        filteredCommands = []
        for cmdObj in cmdObjDict:
            generatedText = str(cmdObj)
            cmdDict = {"name": cmdObjDict[cmdObj][0], # we take the first alias
                       "in_use": (len(generatedText.strip()) > 0),
                       "generated_text": generatedText,
                       "aliases": cmdObjDict[cmdObj]}
            filteredCommands.append(cmdDict)
        return filteredCommands

    def addOrChangeCommand(self, fullText, command=None):
        """
        Add a new Kickstart command, or modify an existing one.
        To add a new command, just pass the whole commandline in `fullText`.
        To change an existing command, it is preferable to pass the command
        name (or an alias) in `command` so that the old commandline can be
        erased first.
        """
        self._checkKsParser()
        if command is not None:
            cmdObj = self.kickstartParser.handler.commands[command]
            if cmdObj.dataList() is not None:
                # we must do something to erase old data objects
                del cmdObj.dataList()[:]
            else:
                # nothing to do since the reading of the new command options
                # will erase the old command options
                pass
        # call main parser with str(fulltext) in case of fullText is unicode
        try:
            self.kickstartParser.readKickstartFromString(str(fullText), reset=False)
        except kserrors.KickstartError as ke:
            raise ObsLightErr.ObsLightKickstartError(str(ke))

    def removeCommand(self, command):
        """
        Remove `command` from the Kickstart file.
        `command` must be a command name or an alias,
        but not the whole text generated by a command.
        """
        self._checkKsParser()
        cmdObj = self.kickstartParser.handler.commands[command]
        # If command has multiple data, clear them.
        if cmdObj.dataList() is not None:
            del cmdObj.dataList()[:]
        # Else reset the command object
        elif len(str(cmdObj).strip()) > 1:
            cmdObj.__init__()
# --- end Commands -----------------------------------------------------------

# --- Scripts ----------------------------------------------------------------
    def getScriptDictList(self):
        """
        Get a list of script dictionaries containing (default value):
          "name": the name of the script (generated by OBS Light)
          "type": the type of script, one of
               pykickstart.constants.[KS_SCRIPT_PRE, KS_SCRIPT_POST, KS_SCRIPT_TRACEBACK]
          "interp": the interpreter to use to run the script ('/bin/sh')
          "errorOnFail": whether to quit or continue the script if a command fails (False)
          "inChroot": whether to run inside chroot or not (False)
          "logfile": the path where to log the output of the script (None)
          "script": all the lines of the script
        """
        self._checkKsParser()
        scriptDictList = []
        for scriptObj in self.kickstartParser.handler.scripts:
            # do not add overlay file scripts
            if scriptObj.script.lstrip().startswith(self.OverlayFileScriptTag):
                continue
            # make a copy of the object's attribute dictionary
            scriptDict = dict(scriptObj.__dict__)
            # remove the line number since we don't care
            scriptDict.pop("lineno", None)
            # find or generate a name for the script
            if scriptObj in self._scriptNameMap:
                scriptName = self._scriptNameMap[scriptObj]
            else:
                scriptName = "script %d" % self._scriptCounter
                self._scriptCounter += 1
            scriptDict["name"] = scriptName
            # save the name of the script
            self._scriptNameMap[scriptName] = scriptObj
            self._scriptNameMap[scriptObj] = scriptName

            scriptDictList.append(scriptDict)
        return scriptDictList

    def addOrChangeScript(self, name=None, script="", **kwargs):
        """
        Add a new Kickstart script, or modify an existing one.
        To add a new script, leave `name` at None.
        To change an existing script, you must pass the script name
        in `name`. `script` and other keyword args are those described
        in `getScriptDictList()`.
        """
        if name is not None and name in self._scriptNameMap:
            scriptObj = self._scriptNameMap[name]
            scriptObj.__dict__.update({"script": str(script)})
            scriptObj.__dict__.update(kwargs)
        else:
            scriptObj = kickstart.ksparser.Script(script=script, **kwargs)
            self.kickstartParser.handler.scripts.append(scriptObj)

    def removeScript(self, scriptName):
        """
        Remove script `scriptName` from the Kickstart file.
        """
        if self._scriptCounter < 1:
            # scripts have never been parsed
            self.getScriptDictList()
        # get the script object and remove it from the name map
        scriptObj = self._scriptNameMap.pop(scriptName, None)
        # if it was not in the map, just return
        if scriptObj is None:
            return
        # remove the script object from Kickstart
        self.kickstartParser.handler.scripts.remove(scriptObj)
        # remove the name of the script from the name map
        self._scriptNameMap.pop(scriptObj)
# --- end Scripts ------------------------------------------------------------

# --- Overlay files ----------------------------------------------------------
    def getOverlayFileDictList(self):
        """
        Get a list of overlay file dictionaries containing:
          "source": the path of the file to be copied
          "destination": the path where the file will be copied
                         in target file system
          "status": "OK" if source file is present,
                    "missing" if it is missing
        """
        self._checkKsParser()
        overlayDictList = []
        for scriptObj in self.kickstartParser.handler.scripts:
            scriptText = scriptObj.script.strip()
            # Do not add regular scripts
            if not scriptText.startswith(self.OverlayFileScriptTag):
                continue

            overlayDict = {}
            isAbsolute = False

            for scriptLine in scriptText.splitlines():
                scriptLine = scriptLine.lstrip()

                # This line contains the name of the source file
                if scriptLine.startswith(self.OverlayFileSourceTag):
                    src = scriptLine[len(self.OverlayFileSourceTag):].strip()
                    # If src is an absolute path, it may be located outside
                    # of the project directory. If possible, fix it.
                    isAbsolute = os.path.isabs(src)
                    if isAbsolute:
                        src = self._copySourceFileIfNecessary(src)
                    # Build the full path where source file is (or should be)
                    overlayDict["source"] = os.path.join(self.overlayFilesDirectory, src)
                    isOk = os.path.exists(overlayDict["source"])
                    overlayDict["status"] = "OK" if isOk else "missing"

                # This line contains the path of the destination file
                elif scriptLine.startswith(self.OverlayFileDestinationTag):
                    dst = scriptLine[len(self.OverlayFileDestinationTag):].strip()
                    overlayDict["destination"] = dst

                # We already got our paths, no need to continue
                if "source" in overlayDict and "destination" in overlayDict:
                    break

            # Rewrite script with relative source path if source is not missing
            if isAbsolute and overlayDict["status"] != "missing":
                scriptObj.script = self._generateCopyScript(overlayDict["source"],
                                                            overlayDict["destination"])
                self.saveKickstart()

            # save the name of the script
            scriptName = overlayDict["source"] + " " + overlayDict["destination"]
            self._scriptNameMap[scriptName] = scriptObj
            self._scriptNameMap[scriptObj] = scriptName

            overlayDictList.append(overlayDict)

        return overlayDictList

    def _createOverlayDirectory(self):
        """
        Create an "overlays" sub-directory of project directory
        (if it does not exist already).
        """
        if not os.path.isdir(self.overlayFilesDirectory):
            os.mkdir(self.overlayFilesDirectory)

    def _copySourceFileIfNecessary(self, source):
        """
        Copy `source` to the overlay files directory if it is not
        already there, and return the basename of the file.
        """
        fileName = os.path.basename(source)
        self._createOverlayDirectory()
        wantedPath = os.path.join(self.overlayFilesDirectory,
                                  fileName)
        if os.path.abspath(source) != wantedPath and os.path.exists(source):
            shutil.copy(os.path.abspath(source), wantedPath)
        return fileName

    def _generateCopyScript(self, source, destination):
        """
        Generate the shell script that will make the copy from `source`
        to `destination` (or extract `source` into `destination`)
        in the file system created by MIC.
        """
        # We need only the name of the file since all overlays
        # are supposed to be in the same directory.
        source = os.path.basename(source)

        # Prepare script header.
        copyScript = self.OverlayFileScriptTag + "\n"
        copyScript += self.OverlayFileSourceTag + source + "\n"
        copyScript += self.OverlayFileDestinationTag + destination + "\n"

        # Re-construct the full path of the source file.
        fullSourcePath = os.path.join(self.overlayFilesDirectory, source)

        # Test if source is an archive or not.
        sourceIsArchive = fileIsArchive(fullSourcePath, tarArchive=True)

        # Split destination file and destination directory.
        if destination.endswith("/") or sourceIsArchive:
            destFileName = ""
            chrootDestDir = '$INSTALL_ROOT%s' % destination
        else:
            destFileName = destination[destination.rfind("/") + 1:]
            chrootDestDir = '$INSTALL_ROOT%s' % destination[:destination.rfind("/") + 1]

        # Create destination directory if it does not exist.
        copyScript += '[ -d "%s" ] || mkdir -p "%s"\n' % (chrootDestDir, chrootDestDir)
        if sourceIsArchive:
            # Do the extraction.
            copyScript += self.UntarCommand % {"source": fullSourcePath,
                                               "destination": chrootDestDir}
        else:
            # Do the copy.
            copyScript += 'cp "%s" "%s"\n' % (fullSourcePath, chrootDestDir + destFileName)

        return copyScript

    def addOverlayFile(self, source, destination):
        """
        Add a new overlay file. `source` is the path where the file
        is currently located, `destination` is the path where the file
        will be copied in the target filesystem.
        """
        self._checkKsParser()
        sourceFileName = self._copySourceFileIfNecessary(str(source))
        destination = str(destination)
        if not destination.startswith("/"):
            destination = "/" + destination

        copyScript = self._generateCopyScript(sourceFileName, destination)
        scriptName = sourceFileName + " " + destination
        scriptObj = kickstart.ksparser.Script(script=copyScript,
                                              inChroot=False,
                                              type=1)
        self.kickstartParser.handler.scripts.append(scriptObj)
        self._scriptNameMap[scriptName] = scriptObj
        self._scriptNameMap[scriptObj] = scriptName

    def removeOverlayFile(self, source, destination):
        """
        Remove the overlay file which was to be copied
        from `source` to `destination`.
        """
        self._checkKsParser()
        scriptName = source + " " + destination
        scriptObj = self._scriptNameMap.get(scriptName, None)
        if scriptObj is not None:
            self.kickstartParser.handler.scripts.remove(scriptObj)
            self._scriptNameMap.pop(scriptObj)
            self._scriptNameMap.pop(scriptName)

# --- end Overlay files ------------------------------------------------------
